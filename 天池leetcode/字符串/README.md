# 字符串简介
简称为串，是由零个或多个字符组成的有限序列

> str = "Hello World"

在上面示例代码中，str是一个字符串的变量名称，Hello World则是该字符串的值，字符串的长度为11.

根据字符串的特点，我们可以将字符串问题分为以下几种：
- 字符串匹配问题
- 子串相关问题
- 前缀/后缀相关问题
- 回文串相关问题
- 子序列相关问题

# 字符串的比较
## 字符串的比较操作
比起数字相对复杂一点，字符串之间的大小取决于它们按顺序排列字符的前后顺序

比如说字符串str1 = "abc"和str2 = "acd",它们第一个字母都是a，而第二个字母，由于字母b比字母c更靠前，所以 b 《 c，于是我们可以说"abc" < "acd",也可以说str1 < str2

字符串之间的比较是通过组成字符串的字符之间的[字符编码]来决定的。而字符编码指的是字符在对应字符集中的序号。

如果比较到某一个字符串末尾，另一个字符串仍有剩余：

- 如果字符串str1的长度小于字符串str2，即len(str1)<len(str2),则str1<str2

按照上面的规则，我们可以定义一个strcmp方法，并且规定：
- 当str1<str2时，strcmp方法返回-1
- 当str1==str2时，strcmp方法返回0
- 当str1>str2时，strcmp方法返回1

```python
def strcmp(str1,str2):
    index1,index2 = 0, 0
    while index1 < len(str1) and index2 < len(str2):
        if ord(str1[index1]) == ord(str2[index2]):
            index1 += 1
            index2 += 1
        elif ord(str1[index1]) < ord(str2[index2]):
            return -1
        else:
            return 1
        
    if len(str1) < len(str2):
        return -1
    elif len(str1) > len(str2):
        return 1
    else:
        return 0
```

## 字符串的字符编码
以计算机中常用字符使用的ASCII编码为例，包含了大小写的英文字母、数字和一些符号对应一个编码。
比如大写字母A的编码是65，小写字母a的编码是97。

世界上有上百种语言，各国有各国的标准，于是就产生了Unicode编码。其中最常用的就是UTF-8编码。
UTF-8把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节。

# 字符串的存储结构
跟线性表相同，分为[顺序存储结构]和[链式存储结构]

# 字符串匹配问题
字符串匹配又称为 **模式匹配** ，可以简单理解为给定字符串 T 和 P ，在主串 T 中寻找字串 P 。
主串 T 又被称为 **文本串** ，子串 P 又被称为 **模式串** 。

在字符串问题中，最重要的问题之一就是字符串匹配问题。而按照模式串的个数，我们可以将字符串匹配问题分为： **单模式串匹配问题** 和 **多模式串匹配问题** 

## 单模式串匹配问题
给定一个文本串 T =t1t2t3...tn，再给定一个特定模式串 P =p1p2...pn。要求从文本串 T 找出特定模式串 P 的所有出现位置。

根据在文本中搜索模式串方式的不同，我们可以将单模式匹配算法分为以下三种：

- 基于前缀搜索方法：在搜索窗口内从前向后（沿着文本的正向）逐个读入文本字符，搜索窗口中文本和模式串的最长公共前缀。

    - 著名的 KMP 算法和更快的 Shift-Or 算法使用的就是这种算法

- 基于后缀搜索方法：在搜索窗口内从后向前（沿着文本的反向）逐个读入文本字符，搜索窗口内文本和模式串的最长公共后缀。使用这种搜索算法可以跳过一些文本字符，从而具有亚线性的平均时间复杂度。

    - 最著名的 BM算法，以及 Horspool算法，Sunday算法都使用了这个算法

- 基于子串搜索方法：在搜索窗口内从后向前（沿着文本的反向）逐个读入文本字符，搜索满足[既是窗口中文本的后缀，也是模式串的子串]的最长字符串。与后缀搜索方法一样，使用这种搜索方法也具有亚线性的平均时间复杂度。这种方法的主要缺点在于需要识别模式串的所有子串，这是一个非常复杂的问题。
    - Rabin-Karp算法， BDM算法，BNDM算法和BOM算法使用的就是这种思想。其中Rabin-Karp算法使用了基于散列的子串搜索算法。

## 多模式串匹配问题
给定一个文本串 T =t1t2t3...tn，再给定一个模式串 P = {p1,p2...pr}，其中每个模式串pl是定义在有限字母表上的字符串。要求从文本串T中找到模式串集合P中所有模式串pl的所有出现位置。

模式串集合P中的一些字符串可能是集合中其他字符串的子串、前缀、后缀，或者完全相等。解决多模式串匹配最简单的方法是利用[单模式串匹配算法]搜索r遍。这将导致预处理阶段的最坏时间复杂度为O（|P|），搜索阶段的最坏时间复杂度为O（r * n）。

如果使用[单模式串匹配算法]解决多模式匹配问题，那么根据在文本中搜索模式串方式的不同，我们也可以将多模式串匹配算法分为以下三种：

- 基于前缀搜索方法：搜索从前向后（沿着文本的正向）进行，逐个读入文本字符，使用在p上构建的自动机进行识别。对于每个文本位置，计算既是已读入文本的后缀，同时也是p中某个模式串的前缀的最长字符串。
    - 著名的AC自动机算法、Multiple Shift-And算法使用的这种方法。

- 基于后缀搜索方法：搜索从后向前（沿着文本的反向）进行，搜索模式串的后缀。根据后缀的下一次出现位置来移动当前文本位置。这种方法可以避免读入所有的文本字符。
    - Set Horspool算法、Wu-Manber算法使用了这种方法。

- 基于子串搜索方法：搜索从后向前（沿着文本的反向）进行，在模式串的长度为min(len(pl))的前缀中搜索子串，以此决定当前文本位置的移动。这种方法也可以避免读入所有的文本字符。
    - Multiple BNDM算法、SBDM算法、SBOM算法都使用了这种方法。

多模式串匹配算法大多使用了一种基本的数据结构： **字典树（Trie）**。著名的 **AC自动机算法** 就是在  **KMP算法 ** 的基础上，与字典树结构相结合而诞生的。而AC自动机算法也是多模式串匹配算法中最有效的算法之一。

所以学习多模式匹配算法，重点是要掌握 **字典树** 和 **AC自动机算法** 

# 单模式串朴素匹配算法
Brute Force算法：暴力匹配算法，也称为朴素匹配算法。

BF算法思想：文本串和模式串从第一个字符开始匹配，没有的话就从第二个字符重新进行比较，直到模式串中每个字符依次与文本串的一个连续子串相等，则模式匹配成功，否则失败。

```python
def bruteForce(T: str, p: str) -> int:
    n, m = len(T), len(p)

    i, j = 0, 0       # i表示T当前位置，j表示P当前位置
        
    while i < n and j < m:   # i或j其中一个到达尾部时停止搜索
        if T[i] == p[j]:     # 如果相等，则进行下一个字符串的匹配
            i += 1
            j += 1
        else:
            i = i - (j - 1)  # 如果匹配失败则将i移动到上次匹配开始位置的下一个位置
            j = 0            # 匹配失败 j 回退到模式串开始位置

    if j == m:
        return i - j         # 匹配成功，返回匹配的开始位置
    else:
        return -1            # 匹配失败，返回-1   
```
- BF算法简单，容易理解，但效率低，还会进行回溯，每轮比较需要进行m次字符对比，总共需要进行n-m+1轮比较，总的比较次数为m*(n-m+1),所以BF算法的最坏时间复杂度为O（m*n）
- 在最理想的情况下（第一次匹配直接匹配成功）,BF算法的最佳时间复杂度为O(m)
- 在一般情况下。根据等概率原则，平均搜索次数为(n+m)/2,所以平均时间复杂度为O（n+m）

# 单模式串KMP匹配算法
当有不匹配的时候，可以利用匹配失败的信息尽量减少模式串和文本串的的匹配次数

```python
# 生成next数组
# next[j]表示下标j之前的模式串p中，最长相等前后缀的长度
def generateNext(p: str):
    m =len(p)
    next = [0 for _ in range(m)]   # 初始化数组元素全部为0

    left = 0      # left表示前缀串开始所在的下标位置
    for right in range(1, m):  # right表示后缀串开始所在的下标位置
        while left > 0 and p[left] != p[right]:   # 匹配不成功，left进行回退，left==0时停止回退
            left = next[left - 1]       # left进行回退操作
        if p[left] == p[right]:        # 匹配成功，找到相同的前后缀，先让left+=1，此时left为前缀长度
            left += 1      
        next[right] = left      # 记录前缀长度，跟新next[right]，结束本次循环，right+=1

    return next

# T为文本串，p为模式串
def KMP(T: str, p: str) -> int:
    n, m = len(T), len(p)

    next = generateNext(p)   # 生成next数组

    j = 0     
    for i in range(n):
        while j > 0 and T[i] != p[j]:  # 如果模式串前缀匹配不成功，将模式串进行回退，j==0时停止回退
            j = next[j - 1]
        if T[i] == p[j]:   # 当前模式串前缀匹配成功，令j+=1，继续匹配
            j += 1
        if j == m:         # 当前模式串完全匹配成功，返回匹配开始位置
            return i - j + 1 
    return -1     # 匹配失败，返回-1
```

### 算法分析
- KMP算法在构造前缀表阶段的时间复杂度为O（m），其中m是模式串p的长度
- 在匹配阶段为O（n），整个算法复杂度为O（m+n）

# 例题解析
## 验证回文串
> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

> 说明：本题中，我们将空字符串定义为有效的回文串。

### 示例1
```
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
```

### 示例2
```
输入: "race a car"
输出: false
解释："raceacar" 不是回文串
```

### 实现代码
```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s) - 1

        while left < right:
            if not s[left].isalnum():
                left += 1
                continue
            if not s[right].isalnum():
                right -= 1
                continue

            if s[left].lower() == s[right].lower():
                left += 1
                right -= 1
            else:
                return False
        return True
```
### 解题思路
使用对撞指针求解
- 使用两个指针left和right。一个开始一个结束
- 判断两个指针对应字符是否是字母或数字。通过left右移，right左移的方式过滤掉字母和数字外的字符
- 然后判断s[start]是否和s[end]相等（注意大小写）
    - 如果相等，则将left右移,right左移，继续进行下一次过滤和判断
    - 如果不相等，则说明不是回文串，直接返回False
- 如果遇到left==right，跳出循环，则说明该字符串是回文串，返回True

## 翻转字符串里的单词
> 给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

> 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

> 请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

- 输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
- 翻转后单词间应当仅用一个空格分隔。
- 翻转后的字符串中不应包含额外的空格。

### 示例1
```
输入：s = "the sky is blue"
输出："blue is sky the"
```
### 示例2
```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。
```
### 实现代码
```pytohn
class Solution:
    def reverseWords(self, s: str) -> str:
        words = []
        cur = ""
        for ch in s:
            if ch == ' ':
                if cur:
                    words.append(cur)
                    cur = ""
            else:
                cur += ch
        
        if cur:
            words.append(cur)

        for i in range(len(words) // 2):
            words[i], words[len(words) - 1 - i] = words[len(words) - 1 - i], words[i]

        return " ".join(words)
```
### 解题思路
第一种思路比较简单，就是直接调用python中的库函数，对字符串进行切片，翻转，然后拼合成字符串。
第二种思路根据API的思路写出模拟代码，具体步骤如下：
- 使用数组words存放单词，使用字符串变量cur存放当前单词
- 遍历字符串，对于当前字符ch
- 如果遇到空格，则：
    - 如果当前单词不为空，则将当前单词存入数组words中，并将当前单词置为空串
- 如果遇到字符，则：
    - 将其存入到当前单词中，即cur += ch
- 如果遍历完，当前单词不为空，则将当前单词存入数组words中
- 然后对数组words进行翻转操作，令words[i], words[len(words) - 1 - i]交换元素
- 最后将words中的单词连接起来，中间拼接上空格，将其作为答案返回。



# 课后习题
## 验证回文字符串 Ⅱ
> 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

### 示例1
```
输入: s = "aba"
输出: true
```
### 示例2
```
输入: s = "abca"
输出: true
解释: 你可以删除c字符。
```

## Excel表列名称
> 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

### 示例1
```
输入：columnNumber = 1
输出："A"
```

### 示例2
```
输入：columnNumber = 701
输出："ZY"
```

## 字符串解码
> 给定一个经过编码的字符串，返回它解码后的字符串。

> 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

### 示例1
```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

### 示例2
```
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

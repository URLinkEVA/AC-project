# 数的定义与相关概念
## 从链表与图开始讲起
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.next = next
        self.val = val
```
单链表：一个数据域+一个指针域

树：一个数据域+多个指针域

图：顶点集+边

树：无环连通图

## 数的定义
 树是N（N>=0）个节点的有限集合。N=0时为空树，N>0时应满足：
1. 有且仅有一个特定的称为根的节点
2. N>1时，其余节点可分为m(m>0)个互不相交的有限集合。其中，每一个有限集合自身也是一棵树。

## 树的相关概念
- 根节点：非空树处于最上层的唯一节点，其余节点都是它的子孙后代 
- 节点的度：节点具有的孩子节点个数
- 叶子节点：度为 0 的节点
- 父子节点：直接相连的一对节点， 处于上层的是父节点， 处于下层的是子节点
- 兄弟节点：由同一个父节点生出的不同节点互称兄弟节点
- 节点层次：由根开始记为1 层， 其子节点为2 层， 孙子节点为3 层“
- 节点深度：节点所在的层次数
- 树的深度/高度：树的最大层次数
- 节点高度：以节点为根的子树的深度/高度
- 有序树：以兄弟节点为根的子树交换位置得到的新树视作与原来的树不同的树
- 无序树：以兄弟节点为根的子树交换位置得到的新树视作与原来的树相同的树

## 简单又独特的树一一二叉树
### 定义
二叉树是一种每个节点度都不大于2的树。其中，每个节点的子节点有左右之分且左右子节点所在的子树不可以交换位置，即二叉树是一棵有序树

### 特殊的二叉树
#### 满二叉树
所有叶子节点全部在最底层，且所有非叶子节点度都是2的树

记满二叉树T高度为h，节点总数为n，n=2^h-1 ， 第k层节点总数为2^(k-1)

从1开始， 对T从上到下，从左到右进行编号。如果编号i的节点有父节点，则其父节点编号为[i/2], 如果有左子节点，则其左子节点编号为2i，如果有右子节点，则其右子节点编号为2i+1

#### 完全二叉树
记二叉树高度为h。从1开始，对二叉树从上到下，从左到右进行编号。对高度同为h的满二叉树做同样的编号处理。如果二叉树中所有节点的编号都能与满二叉树中同样位置的节点编号一致，则该二叉树是一棵完全二叉树。

完全二叉树的叶子节点只可能存在于最下面的两层中，且最下层的叶子节点全部是靠左紧密排列的

完全二叉树中父子节点之间的编号规律与满二叉树的规律完全相同，且编号大于[n/2]的节点必是叶子节点

如果n为奇数，则每个非叶子节点都有两个子节点；如果n为偶数，则第n/2个节点必为非叶子节点，且它只有左子结点而无右子节点，其余非叶子节点都有两个子节点



# 例题解析


# 课后习题
## 二叉树的最小深度
> 给定一个二叉树，找出其最小深度。

> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

> 说明：叶子节点是指没有子节点的节点。

### 示例1
```
输入：root = [3,9,20,null,null,15,7]
输出：2
```
### 示例2
```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

## 路径总和
> 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

> 叶子节点 是指没有子节点的节点。

### 示例1
```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径存在。
```

### 示例2
```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

## 二叉搜索树迭代器
> 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
- BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
- boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。
- int next()将指针向右移动，然后返回指针处的数字。
> 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。

> 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。

### 示例
```
输入
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]

解释
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False
```


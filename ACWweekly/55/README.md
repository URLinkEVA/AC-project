# 最长子序列
给定一个长度为 n 的序列 a1,a2,…,an 和一个长度为 m 的序列 b1,b2,…,bm。

现在，我们希望找到一个序列 a 的子序列，使得该子序列满足：
- 子序列中的每一个元素都在序列 b 中出现过。
- 子序列的长度应尽可能长。

请你输出满足条件的最长子序列。

## 输入格式
第一行包含两个整数 n,m。

第二行包含 n 个整数 a1,a2,…,an。

第三行包含 m 个整数 b1,b2,…,bm。

## 输出格式
在一行中输出满足条件的最长子序列。

如果满足条件的最长子序列为空，则不输出任何内容或输出单个换行符均可。

## 数据范围
所有测试点满足 1≤n,m≤10，0≤ai,bi≤9。

```
输入样例1：
7 3
3 5 7 1 6 2 8
1 2 7
输出样例1：
7 1 2
输入样例2：
4 4
3 4 1 0
0 1 7 9
输出样例2：
1 0
```

# 倒垃圾
一条街道可以看作一个数轴。

街道上住着 n 个居民并设有 m 个垃圾桶，每个居民的住所或垃圾桶占据一个位置。

已知，这 n+m 个位置两两不同。

每个居民每天都会前往距离自己家最近的垃圾桶处倒垃圾。

如果这样的垃圾桶不唯一，则居民会优先选择前往位置坐标更小的垃圾桶处倒垃圾。

请你计算，对于每个垃圾桶，每天有多少居民在该垃圾桶处倒垃圾。

## 输入格式
第一行包含两个整数 n,m。

第二行包含 n+m 个整数 x1,x2,…,xn+m，表示所有居民住所以及垃圾桶的位置坐标。

第三行包含 n+m 个整数 t1,t2,…,tn+m，如果 ti=1，则表示第 i 个位置坐标处是垃圾桶，如果 ti=0，则表示第 i 个位置坐标处是居民住所。

输入保证，满足 ti=1 的 i 的数量为 m。

## 输出格式
不妨按照位置坐标从小到大的顺序，将 m 个垃圾桶编号 1∼m。

请你在一行中输出 m 个整数 a1,a2,…,am，其中 ai 表示每天在第 i 个垃圾桶处倒垃圾的居民数量。

## 数据范围
前三个测试点满足 1≤n,m≤5。

所有测试点满足 1≤n,m≤105，1≤x1<x2<…<xn+m≤109，0≤ti≤1。

```
输入样例1：
3 1
1 2 3 10
0 0 1 0
输出样例1：
3
输入样例2：
3 2
2 3 4 5 6
1 0 0 0 1
输出样例2：
2 1
输入样例3：
1 4
2 4 6 10 15
1 1 1 1 0
输出样例3：
0 0 0 1
```

# 方格探索
给定一个 n 行 m 列的方格矩阵。行坐标从上到下为 1∼n，列坐标从左到右为 1∼m。

其中的每个方格，要么是空格（用 . 表示），要么包含障碍物（用 * 表示）。

初始时，一个人位于第 r 行第 c 列的空格之中。

他可以沿上下左右四个方向进行移动，每次移动一格距离。

对于他的移动，有如下限制：
- 他不能进入到包含障碍物的方格中，也不能走出矩阵的边界。
- 在整个移动过程中，他向左移动的总次数不能超过 x 次。
- 在整个移动过程中，他向右移动的总次数不能超过 y 次。

请问，一共有多少个空格是此人可以抵达的？

注意，初始空格视为此人可达。

## 输入格式
第一行包含两个整数 n,m。

第二行包含两个整数 r,c。

第三行包含两个整数 x,y。

接下来 n 行，每行包含一个长度为 m 的由 . 和 * 组成的字符串，用来描述方格矩阵。

输入保证第 r 行第 c 列的方格一定是空格。

## 输出格式
一个整数，表示可达空格数量。

## 数据范围
前三个测试点满足 1≤n,m≤5。

所有测试点满足 1≤n,m≤2000，1≤r≤n，1≤c≤m，0≤x,y≤109。

```
输入样例1：
4 5
3 2
1 2
.....
.***.
...**
*....
输出样例1：
10
输入样例2：
4 4
2 2
0 1
....
..*.
....
....
输出样例2：
7
```

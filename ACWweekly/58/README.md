# 寻找1
给定一个长度为 n 的 01 序列 a1,a2,…,an。

请你判断，其中是否包含 1。

## 输入格式
第一行包含一个整数 n。

第二行包含 n 个整数 a1,a2,…,an。

## 输出格式
如果序列中包含 1，则输出 YES，否则输出 NO。

## 数据范围
前三个测试点满足 1≤n≤3。

所有测试点满足 1≤n≤100，0≤a_i≤1。
```
输入样例1：
3
0 0 1
输出样例1：
YES
输入样例2：
1
0
输出样例2：
NO
```

[同类型](https://blog.csdn.net/Moriafly/article/details/106248801)

# 最长子序列
给定一个长度为 n 的严格单调递增的整数序列 a1,a2,…,an。

序列 a 的子序列可以表示为 ai1,ai2,…,aip，其中 1≤i1<i2<…<ip≤n。

我们希望找到一个 a 的子序列，使得该子序列满足：对于 j∈[1,p−1]，aij+1≤aij×2 恒成立。

我们认为，长度为 1 的子序列总是满足条件的。

请你计算并输出满足条件的子序列的最大可能长度。

## 输入格式
第一行包含一个整数 n。

第二行包含 n 个整数 a1,a2,…,an。

## 输出格式
一个整数，表示满足条件的子序列的最大可能长度。

## 数据范围
前 5 个测试点满足 1≤n≤10。

所有测试点满足 1≤n≤2×10^5，1≤a1<a2<…<an≤10^9。
```
输入样例1：
10
1 2 5 6 7 10 21 23 24 49
输出样例1：
4
输入样例2：
5
2 10 50 110 250
输出样例2：
1
输入样例3：
6
4 7 12 100 150 199
输出样例3：
3
```

# 染色
给定一个 n 个节点的树，节点编号为 1∼n。

1 号节点是树的根节点。

初始时，所有节点的颜色均为 0。

现在，你需要对该树进行重新染色，其中节点 i 的目标颜色为 ci。

每次染色操作的具体流程如下：
- 选择一个节点 v 和一种颜色 x。
- 将以节点 v 为根节点的子树中的全部节点（包括节点 v）都染成颜色 x。

请你计算，为了使得每个节点都被染成目标颜色，至少需要进行多少次染色操作。

## 输入格式
第一行包含整数 n。

第二行包含 n−1 个整数 p2,p3,…,pn，其中 pi 表示节点 i 的父节点编号。

第三行包含 n 个整数 c1,c2,…,cn，其中 ci 表示节点 i 的目标颜色。

保证输入给定图是一棵树。

## 输出格式
一个整数，表示最少所需的染色操作次数。

## 数据范围
前三个测试点满足 2≤n≤10。

所有测试点满足 2≤n≤10^4，1≤p_i<i，1≤c_i≤n。

```
输入样例1：
6
1 2 2 1 5
2 1 1 1 1 1
输出样例1：
3
输入样例2：
7
1 1 2 3 1 4
3 3 1 1 1 2 3
输出样例2：
5
```
